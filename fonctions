#include "header.h"

void MenuPrincipal(time_t debut)
{
    time_t fin;
    int diff_t;
    BITMAP *Buffer;
    Buffer = create_bitmap(SCREEN_W, SCREEN_H);
    clear_bitmap(Buffer);
    BITMAP *StartSimCity;
    StartSimCity = load_bitmap("MenuDebut.bmp", NULL);
    BITMAP *ChoixMode;
    ChoixMode = load_bitmap("choixMode.bmp", NULL);
    if(StartSimCity==NULL)
    {
        allegro_message("Pb de image") ;
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    if(ChoixMode==NULL)
    {
        allegro_message("Pb de image") ;
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    int mode = 0;;
    while(!key[KEY_SPACE])
    {
        blit(StartSimCity, Buffer, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    }

    destroy_bitmap(StartSimCity);
    blit(ChoixMode, Buffer, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    while(mode == 0)
    {
        if(mouse_x >= 250 && mouse_x <= 550 && mouse_y >= 400 && mouse_y <= 500 && mouse_b & 1)  //Capitaliste
        {
            mode = 2;
        }
        else if(mouse_x >= 890 && mouse_x <= 1300 && mouse_y >= 400 && mouse_y <= 500 && mouse_b & 1) //Communiste
        {
            mode = 3;
        }
    }
    destroy_bitmap(ChoixMode);
    time(&fin);
    diff_t = difftime(fin, debut);
    jeu(mode, Buffer, diff_t);

}

void horloge(BITMAP *Buffer, clock_t temps, int *a, int *back, int *i, int *min, int diff_t)
{
    //printf("8 ");
    temps = clock();
    if(temps > *a)
    {

        //printf("TIME : %d min %d s \n", min,((int)temps / CLOCKS_PER_SEC)-back);
        //textout_ex(screen, font, "TIME : %d min %d s", min,((int)temps / CLOCKS_PER_SEC)-back, SCREEN_W/2-20, 0, makecol(0, 0, 255), -1);
        textprintf(Buffer,font,110,111,makecol(0,255,255),"TIME : %d min %d  s", *min,((int)temps / CLOCKS_PER_SEC)-(*back)-diff_t);

        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
       /* printf("a = %d\n", *a);
        printf("back = %d\n", *back);
        printf("i = %d\n", *i);
        printf("min = %d\n", *min);*/
        *a = *a + 1000;
        if((*a/(*i))>=60000)
        {
            *back = 60*(*i);
            *i = *i + 1;
            *min = *min + 1;
        }

    }
}

void jeu(int modeJeu, BITMAP *Buffer, int diff_t)
{
    srand(time(NULL));
    clock_t temps; //Une structure contenant le temps
    //int tm_min;
    temps = clock();
    int a = 0;
    int back = 0;
    int i = 1;
    int min = 0;
    t_c grille[1575];
    t_v ville;
    clear_bitmap(Buffer);

    coCases(grille, &ville);


    BITMAP *PlateauFond;
    PlateauFond = load_bitmap("grille.bmp", NULL);
    if(PlateauFond==NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *outils;
    outils = load_bitmap("BoiteOutils.bmp", NULL);
    if(outils == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *terrainV;
    terrainV = load_bitmap("TerrainB.bmp", NULL);
    if(terrainV == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *cabane;
    cabane = load_bitmap("CabaneB.bmp", NULL);
    if(outils == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *maison;
    maison = load_bitmap("MaisonB.bmp", NULL);
    if(outils == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *immeuble;
    immeuble = load_bitmap("ImmeubleB.bmp", NULL);
    if(outils == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *gratteciel;
    gratteciel = load_bitmap("GrattecielB.bmp", NULL);
    if(outils == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *eau;
    eau = load_bitmap("ChateaueauB.bmp", NULL);
    if(eau == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *elec;
    elec = load_bitmap("CentraleB.bmp", NULL);
    if(elec == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *eau_E;      //Ecriture eau
    eau_E=load_bitmap("eau.bmp", NULL);
    if(elec == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *centrale_E;     //ecriture centrale electronique
    centrale_E=load_bitmap("centrale_E.bmp", NULL);
    if(centrale_E == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *choix;      //ecritur : choix du niveau
    choix=load_bitmap("choix.bmp", NULL);
    if(choix == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *niveaux;        // Ecriture : niveau 0, niveau 1, niveau 2
    niveaux=load_bitmap("niveaux.bmp", NULL);
    if(niveaux == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *quitter;
    quitter=load_bitmap("Exit.bmp", NULL);
    if(quitter == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    BITMAP *compteurs;      //bitmap compteurs
    compteurs=load_bitmap("compteurs.bmp", NULL);
    if(compteurs == NULL)
    {
        allegro_message("Pb de image");
        allegro_exit();
        exit(EXIT_FAILURE);
    }






    affichageInterface(Buffer, outils, compteurs, eau, elec, eau_E, centrale_E, choix, niveaux, quitter);
    draw_sprite(Buffer, PlateauFond, 550, 75);  //300-->550
    Chargement(grille, Buffer, terrainV, cabane, maison, immeuble, gratteciel, eau, elec);
    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);

    while(!key[KEY_ESC])
    {
        Construction(Buffer, grille, &ville, terrainV, eau, elec, temps, &a, &back, &i, &min, diff_t);
        if(mouse_b & 1 && mouse_x < 830 && mouse_y < 850 && mouse_x > 720 && mouse_y > 800)
        {

            Niveau1(Buffer, grille, PlateauFond, eau);//erreur
        }
        if(mouse_b & 1 && mouse_x < 970 && mouse_y < 850 && mouse_x > 850 && mouse_y > 800)
        {
            Niveau2(Buffer, grille, PlateauFond, elec);//erreur
        }
        horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
        //ville.population = 10;
        ville.modeJeu = 2;
        EvolutionGeneral(grille, &ville, Buffer, cabane, maison, immeuble, gratteciel);


        textprintf(Buffer,font,360,208,makecol(0,255,0),"%d ", ville.argent);
        textprintf(Buffer,font,110,208,makecol(0,255,0),"%d", ville.population);
        textprintf(Buffer,font,360,300,makecol(0,255,0),"%d", ville.capaciteEAU);
        textprintf(Buffer,font,110,300,makecol(0,255,0),"%d", ville.capaciteELEC);


    }
    Fin(grille, &ville);





}


void Fin(t_c grille[1575], t_v *ville)
{
    FILE* end = fopen("./PartieEnregistre.txt","w");
    if (!end)
    {
        printf("Erreur de lecture fichier\n");
        exit(-1);
    }
    int compteur = 0;

    fprintf(end, "%d\n", ville->argent);
    fprintf(end, "%d\n", ville->capaciteEAU);
    fprintf(end, "%d\n", ville->capaciteELEC);
    fprintf(end, "%d\n", ville->impotParJour);
    fprintf(end, "%d\n", ville->nbHabitations);
    fprintf(end, "%d\n", ville->population);

    for(int y = 0; y < 35; y++)
    {

        for(int x = 0; x < 45; x++)
        {
            fprintf(end, "%d ", grille[compteur].etat);
            compteur = compteur+1;
        }
        fprintf(end, "\n");
    }






    fclose(end);
}



void Niveau1(BITMAP *Buffer, t_c grille[1575], BITMAP *plateau, BITMAP *eau)
{

    BITMAP *inter;
    inter = create_bitmap(SCREEN_W, SCREEN_H);
    clear_bitmap(inter);
    draw_sprite(inter, plateau, 550, 75);
    for(int i = 0; i < 1575; i++)
    {
        //si route
        if(grille[i].etat == 1)
        {
            rectfill(inter,grille[i].caseX,grille[i].caseY,grille[i].caseX+20,grille[i].caseY+20,makecol(0,128,255));
        }
        //chateau d'eau
        else if(grille[i].etat == 7)
        {
            affichageBatiments(inter, eau, grille, i);
        }
        else
        {

        }
    }
    blit(inter, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    while(!(mouse_b & 1 && mouse_x < 830 && mouse_y < 850 && mouse_x > 720 && mouse_y > 800))
    {
        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    }
}



void Niveau2(BITMAP *Buffer, t_c grille[1575], BITMAP *plateau, BITMAP *elec)
{

    BITMAP *inter;
    inter = create_bitmap(SCREEN_W, SCREEN_H);
    clear_bitmap(inter);
    draw_sprite(inter, plateau, 550, 75);
    for(int i = 0; i < 1575; i++)
    {
        //si route
        if(grille[i].etat == 1)
        {
            rectfill(inter,grille[i].caseX,grille[i].caseY,grille[i].caseX+20,grille[i].caseY+20,makecol(255,255,0));
        }
        //elec
        else if(grille[i].etat == 8)
        {
            affichageBatiments(inter, elec, grille, i);
        }
        else
        {

        }
    }
    blit(inter, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    while(!(mouse_b & 1 && mouse_x < 970 && mouse_y < 850 && mouse_x > 850 && mouse_y > 800))
    {
        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    }
}





void Construction(BITMAP *Buffer, t_c grille[1575], t_v *ville, BITMAP *terrainV, BITMAP *eau, BITMAP *elec, clock_t temps, int *a, int *back, int *i, int *min, int diff_t)
{
  /*  BITMAP *Buffer2;
    Buffer2 = create_bitmap(60, 60);
    //clear_bitmap(Buffer2);
    //blit(Buffer2, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    Buffer2 = Buffer;

*/

    int fin = 0;
    int CaseDemande;
    int ok = 0;
    int c = 0;
    rect(Buffer,10,470,130,570, makecol(0,0,0));//route
    rect(Buffer,250,470,345,570, makecol(0,0,0));//terrain vide
    rect(Buffer,10,600,90,720, makecol(0,0,0));//eau
    rect(Buffer,260,600,350,720, makecol(0,0,0));//elec

    //int diff_ti;
    //time_t deb;

    //créer route
    if(mouse_b & 1 && mouse_x < 130 && mouse_y < 570 && mouse_x > 10 && mouse_y > 470 && ville->argent-10>=0)///mettre vrai coordonnée
    {

            //time(&deb);

            //horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
            while(fin == 0)
            {
                horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
                if(mouse_x > 550 && mouse_y > 75  && mouse_x < 1450 && mouse_y < 775)
                {
                    horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
                    CaseDemande = trouverCaseRoute(grille);
                   /* if(grille[CaseDemande].etat == 0)
                    {
                        rectfill(screen,grille[CaseDemande].caseX,grille[CaseDemande].caseY,grille[CaseDemande].caseX+20,grille[CaseDemande].caseY+20,makecol(0,0,0));
                        rest(30);
                        horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
                        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                    }*/
                    if(mouse_b & 1)
                    {

                        horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
                        rectfill(Buffer,grille[CaseDemande].caseX,grille[CaseDemande].caseY,grille[CaseDemande].caseX+20,grille[CaseDemande].caseY+20,makecol(0,0,0));
                        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                        grille[CaseDemande].etat = 1;
                        ville->argent -= 10;
                        horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
                    }
                    horloge(Buffer, temps, &a, &back, &i, &min, diff_t);
                }
                if(mouse_b & 2 && mouse_x < 130 && mouse_y < 570 && mouse_x > 10 && mouse_y > 470)///mettre vrai cordonnée
                {

                  /*  //printf("a");
                    time_t finn;
                    time(&finn);
                    diff_ti = difftime(finn, deb);

                    if(diff_ti > 1)
                    {
                        fin = 1;

                    }*/
                    fin = 1;

                }

            }
    }
    //habitations(cabane)
    else if(mouse_b & 1 && mouse_x < 345 && mouse_y < 570 && mouse_x > 250 && mouse_y > 470 && ville->argent-1000>=0)///mettre vrai cordonnée
    {
        rest(500);
        while(fin == 0)
        {
            if(mouse_x > 570 && mouse_y > 95 && mouse_x < 1430 && mouse_y < 755)
            {
                 CaseDemande = trouverCaseHabitations(grille);
                 //verifier 9 cases libres pour y poser une habitation
                 while(c <= 90)
                 {
                     for(int d = 0; d < 3; d++)
                     {
                         if(grille[CaseDemande + d + c].etat == 0)
                         {
                            ok++;
                        }
                     }
                     c = c + 45;
                 }
                 c = 0;
                 //si c'est bon
                 if(ok == 9)
                 {
                    draw_sprite(screen, terrainV, grille[CaseDemande].caseX,grille[CaseDemande].caseY);
                    rest(30);
                    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                 }
                 if(mouse_b & 1 )
                 {

                    draw_sprite(Buffer, terrainV, grille[CaseDemande].caseX,grille[CaseDemande].caseY);
                    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                    grille[CaseDemande].etat = 2;
                    grille[CaseDemande+1].etat = 2;
                    grille[CaseDemande+2].etat = 2;
                    grille[CaseDemande+45].etat = 2;
                    grille[CaseDemande+46].etat = 2;
                    grille[CaseDemande+47].etat = 2;
                    grille[CaseDemande+90].etat = 2;
                    grille[CaseDemande+91].etat = 2;
                    grille[CaseDemande+92].etat = 2;
                    grille[CaseDemande].jefe = 2;
                    //temps
                    time(&grille[CaseDemande].dcycle);
                    ville->argent -= 1000;
                    ville->nbHabitations += 1;
                    fin = 1;
                 }
                 ok = 0;
            }
            if(mouse_b & 2 && mouse_x < 345 && mouse_y < 570 && mouse_x > 250 && mouse_y > 470)///mettre vrai cordonnée
            {
                fin = 1;
            }
        }
    }
    //eau
    else if(mouse_b & 1 && mouse_x < 90 && mouse_y < 720 && mouse_x > 10 && mouse_y > 600 && ville->argent-100000>=0)///mettre vrai cordonnée
    {
        rest(500);
        while(fin == 0)
        {
            if(mouse_x > 590 && mouse_y > 135 && mouse_x < 1430 && mouse_y < 755)
            {
                 CaseDemande = trouverCaseBat(grille);
                 //vetifier si 24 cases libres
                 while(c <= 225)
                 {
                     for(int d = 0; d < 4; d++)
                     {
                         if(grille[CaseDemande + d + c].etat == 0)
                         {
                            ok++;
                        }
                     }
                     c = c + 45;
                 }
                 c = 0;
                 if(ok == 24)
                 {
                    draw_sprite(screen, eau, grille[CaseDemande].caseX,grille[CaseDemande].caseY);
                    rest(30);
                    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                 }
                 if(mouse_b & 1)
                 {
                    draw_sprite(Buffer, eau, grille[CaseDemande].caseX,grille[CaseDemande].caseY);
                    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                    fin = 1;
                    CompleterViteBat(grille,CaseDemande, 1);
                    ville->argent -= 100000;
                    ville->capaciteEAU += 1;
                 }
                ok = 0;
            }
            if(mouse_b & 2 && mouse_x < 90 && mouse_y < 720 && mouse_x > 10 && mouse_y > 600)///mettre vrai cordonnée
            {
                fin = 1;
            }
        }
    }
    //elec
    else if(mouse_b & 1 && mouse_x < 350 && mouse_y < 720 && mouse_x > 260 && mouse_y > 600 && ville->argent-100000>=0)///mettre vrai cordonnée
    {
        rest(500);
        while(fin == 0)
        {
            if(mouse_x > 590 && mouse_y > 135 && mouse_x < 1430 && mouse_y < 755)
            {
                 CaseDemande = trouverCaseBat(grille);
                 //vetifier si 24 cases libres
                 while(c <= 225)
                 {
                     for(int d = 0; d < 4; d++)
                     {
                         if(grille[CaseDemande + d + c].etat == 0)
                         {
                            ok++;
                        }
                     }
                     c = c + 45;
                 }
                 c = 0;
                 if(ok == 24)
                 {
                    draw_sprite(screen, elec, grille[CaseDemande].caseX,grille[CaseDemande].caseY);
                    rest(30);
                    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                 }
                 if(mouse_b & 1)
                 {
                    draw_sprite(Buffer, elec, grille[CaseDemande].caseX,grille[CaseDemande].caseY);
                    blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
                    fin = 1;
                    CompleterViteBat(grille, CaseDemande, 2);
                    ville->argent -= 100000;
                    ville->capaciteEAU += 1;
                 }
                ok = 0;
            }
            if(mouse_b & 2 && mouse_x < 350 && mouse_y < 720 && mouse_x > 260 && mouse_y > 600)///mettre vrai cordonnée
            {
                fin = 1;
            }
        }
    }
    else
    {

    }

}





void coCases(t_c grille[1575], t_v *ville)
{
    printf("test");
    int compteur = 0;
    int compteurX = 550;
    int compteurY = 75;
    int compteurColonne = 1;
    int compteurLigne = 1;
    FILE* ifs = fopen("./GrilleDepart.txt","r");
    if (!ifs)
    {
        printf("Erreur de lecture fichier\n");
        exit(-1);
    }

    int a1;
    fscanf(ifs,"%d",&a1);
    ville->argent = a1;
    fscanf(ifs,"%d",&a1);
    ville->capaciteEAU = a1;
    fscanf(ifs,"%d",&a1);
    ville->capaciteELEC = a1;
    fscanf(ifs,"%d",&a1);
    ville->impotParJour = a1;
    fscanf(ifs,"%d",&a1);
    ville->nbHabitations = a1;
    fscanf(ifs,"%d",&a1);
    ville->population = a1;
    for(int y = 0; y < 35; y++)
    {
        compteurX = 550;
        for(int x = 0; x < 45; x++)
        {
            fscanf(ifs,"%d",&a1);
            grille[compteur].caseX = compteurX;
            grille[compteur].caseY = compteurY;
            grille[compteur].etat = a1;
            grille[compteur].colonne = compteurColonne;
            grille[compteur].ligne = compteurLigne;
            grille[compteur].habitant = 0;
            grille[compteur].jefe = 0;
            compteurColonne = (compteurColonne + 1)%45;
            compteurX = compteurX + 20;
            compteur = compteur+1;
        }
        printf("\n");
        compteurY = compteurY + 20;
        compteurColonne = 1;
        compteurLigne += 1;
    }
    printf("\n\n");

  /*  compteur = 0;
    for(int y = 0; y < 35; y++)
    {

        for(int x = 0; x < 45; x++)
        {
            printf("%d ", grille[compteur].etat);
            compteur = compteur+1;
        }
        printf("\n");
    }*/
    fclose(ifs);
    return ville;
}


int trouverCaseRoute(t_c grille[1575])
{
    int i = 0;
    for(i=0;i<1575;i++)
    {
        if(mouse_x <= grille[i].caseX + 20 && mouse_x >= grille[i].caseX - 20 && mouse_y <= grille[i].caseY + 20 && mouse_y >= grille[i].caseY - 20)
        {
            return i;
        }
    }
}

int trouverCaseHabitations(t_c grille[1575])
{
    int i = 0;
    for(i=0;i<1575;i++)
    {
        if(mouse_x <= grille[i].caseX + 20 && mouse_x >= grille[i].caseX - 20 && mouse_y <= grille[i].caseY + 20 && mouse_y >= grille[i].caseY - 20)
        {
            return i - 46;
        }
    }
}

int trouverCaseBat(t_c grille[1575])
{
    int i = 0;
    for(i=0;i<1575;i++)
    {
        if(mouse_x <= grille[i].caseX + 20 && mouse_x >= grille[i].caseX - 20 && mouse_y <= grille[i].caseY + 20 && mouse_y >= grille[i].caseY - 20)
        {
            return i - 137;
        }
    }
}






void Chargement(t_c grille[1575], BITMAP *Buffer, BITMAP *terrainV, BITMAP *cabane, BITMAP *maison, BITMAP *immeuble, BITMAP *gratteciel, BITMAP *eau, BITMAP *elec)
{

    for(int i = 0; i < 1575; i++)
    {
        //terrain vide = 0
        //route = 1
        if(grille[i].etat == 1)
        {
            rectfill(Buffer,grille[i].caseX,grille[i].caseY,grille[i].caseX+20,grille[i].caseY+20,makecol(0,0,0));
        }
        // terrain vague
        else if(grille[i].etat == 2)
        {
            affichageBatiments(Buffer, terrainV, grille, i);
        }
        //cabane
        else if(grille[i].etat == 3)
        {
            affichageBatiments(Buffer, cabane, grille, i);
        }
        //maison
        else if(grille[i].etat == 4)
        {
            affichageBatiments(Buffer, maison, grille, i);
        }
        //immeuble
        else if(grille[i].etat == 5)
        {
            affichageBatiments(Buffer, immeuble, grille, i);
        }
        //gratte ciel
        else if(grille[i].etat == 6)
        {
            affichageBatiments(Buffer, gratteciel, grille, i);
        }
        //chateau d'eau
        else if(grille[i].etat == 7)
        {
            affichageBatiments(Buffer, eau, grille, i);
        }
        //centrale
        else if(grille[i].etat == 8)
        {
            affichageBatiments(Buffer, elec, grille, i);
        }
        //ruine
        else if(grille[i].etat == 9)
        {
            affichageBatiments(Buffer, elec, grille, i);
        }
        else
        {

        }
    }
}



void affichageInterface(BITMAP *Buffer, BITMAP *outils, BITMAP *compteurs, BITMAP *eau, BITMAP *elec, BITMAP *eau_E, BITMAP *centrale_E, BITMAP *choix, BITMAP *niveaux, BITMAP *quitter)
{

    rectfill(Buffer,0,0,1524, 855, makecol(195,195,195));

    //-------------Boite à outils------------///

    masked_blit(compteurs, Buffer,0, 0,10,10,450,500);
    masked_blit(outils, Buffer, 0, 0, 10, 350, 500, 400);
    rect(Buffer,10,470,520,750, makecol(0,0,0));
    masked_blit(eau, Buffer, 0, 0, 10, 600, 500, 400);
    masked_blit(elec, Buffer, 0, 0, 270, 600, 500, 400);
    masked_blit(eau_E, Buffer, 0,0, 120,640, 200, 100);
    masked_blit(centrale_E, Buffer, 0,0, 380,640, 200, 100);
    masked_blit(choix, Buffer, 0,0, 450,780, 200, 100);
    masked_blit(niveaux, Buffer, 0,0, 600,800, 400, 100);
    rect(Buffer,590,800,700,850, makecol(0,0,0));
    rect(Buffer,720,800,830,850, makecol(0,0,0));
    rect(Buffer,850,800,970,850, makecol(0,0,0));
    masked_blit(quitter, Buffer, 0,0, 1350,800, 200, 100);


}



void affichageBatiments(BITMAP *Buffer, BITMAP *bat, t_c grille[1575], int i)
{
    if(grille[i].colonne == 0 && grille[i].ligne == 0)
    {
        draw_sprite(Buffer, bat, grille[i].caseX,grille[i].caseY);
        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    }
    else if(grille[i].ligne == 0 && grille[i-1].etat != grille[i].etat)
    {
        draw_sprite(Buffer, bat, grille[i].caseX,grille[i].caseY);
        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    }
    else if(grille[i].colonne == 0 && grille[i-45].etat != grille[i].etat)
    {
        draw_sprite(Buffer, bat, grille[i].caseX,grille[i].caseY);
        blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
    }
    else
    {
        if(grille[i-1].etat != grille[i].etat && grille[i-45].etat != grille[i].etat && grille[i-46].etat != grille[i].etat)
        {
            draw_sprite(Buffer, bat, grille[i].caseX,grille[i].caseY);
            blit(Buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
        }
    }

}


void viabiliteBat(t_c grille[1575], int bat)
{

        //angle haut gauche
        if(grille[bat].colonne == 1 && grille[bat].ligne == 1)
        {
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat+3+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat+135+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
        }
        //angle haut droite
        else if(grille[bat].colonne == 43 &&grille[bat].ligne == 1)
        {
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat-1+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat+135+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
        }
        //angle bas gauche
        else if(grille[bat].colonne == 1 && grille[bat].ligne == 33)
        {
            for(int i = (-1); i < 3; i++)
            {
                if(grille[bat+3+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat-45+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
        }
        //angle bas droite
        else if(grille[bat].colonne == 43 && grille[bat].ligne == 33)
        {
            for(int i = (-1); i < 3; i++)
            {
                if(grille[bat-1+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat-45+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
        }
        //si ligne haut
        else if(grille[bat].ligne == 1)
        {
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat+3+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat-1+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat+135+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
        }
        //si col gauche
        else if(grille[bat].colonne == 1)
        {
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat+3+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat+135+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat-45+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }

        }
        //si ligne bas
        else if(grille[bat].ligne == 33)
        {
            for(int i = (-1); i < 3; i++)
            {
                if(grille[bat+3+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat-45+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = (-1); i < 3; i++)
            {
                if(grille[bat-1+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }

        }
        //si col droite
        else if(grille[bat].colonne == 43)
        {

            for(int i = 0; i < 3; i++)
            {
                if(grille[bat-45+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat-1+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat+135+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
        }
        //sinon
        else
        {
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat-45+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat-1+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 3; i++)
            {
                if(grille[bat+135+i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
            for(int i = 0; i < 4; i++)
            {
                if(grille[bat+3+45*i].etat == 1)
                {
                    CompleterViteBat(grille, bat, 3);
                }
            }
        }



    //des qu'on pose un bat, on regarde si viabilité
    //on va regarder les cases autour de lui
    //si il ya une route peut etre viabilité sinon pas viabilité
    //
}



void CompleterViteBat(t_c grille[1575], int CaseDemande, int cas)
{
    //eau etat
    if(cas == 1)
    {
        grille[CaseDemande].etat = 7;
                    grille[CaseDemande+1].etat = 7;
                    grille[CaseDemande+2].etat = 7;
                    grille[CaseDemande+3].etat = 7;
                    grille[CaseDemande+45].etat = 7;
                    grille[CaseDemande+46].etat = 7;
                    grille[CaseDemande+47].etat = 7;
                    grille[CaseDemande+48].etat = 7;
                    grille[CaseDemande+90].etat = 7;
                    grille[CaseDemande+91].etat = 7;
                    grille[CaseDemande+92].etat = 7;
                    grille[CaseDemande+83].etat = 7;
                    grille[CaseDemande+135].etat = 7;
                    grille[CaseDemande+136].etat = 7;
                    grille[CaseDemande+137].etat = 7;
                    grille[CaseDemande+138].etat = 7;
                    grille[CaseDemande+180].etat = 7;
                    grille[CaseDemande+181].etat = 7;
                    grille[CaseDemande+182].etat = 7;
                    grille[CaseDemande+183].etat = 7;
                    grille[CaseDemande+225].etat = 7;
                    grille[CaseDemande+226].etat = 7;
                    grille[CaseDemande+227].etat = 7;
                    grille[CaseDemande+228].etat = 7;
    }
    //elec etat
    if(cas == 2)
    {
                    grille[CaseDemande].etat = 8;
                    grille[CaseDemande+1].etat = 8;
                    grille[CaseDemande+2].etat = 8;
                    grille[CaseDemande+3].etat = 8;
                    grille[CaseDemande+45].etat = 8;
                    grille[CaseDemande+46].etat = 8;
                    grille[CaseDemande+47].etat = 8;
                    grille[CaseDemande+48].etat = 8;
                    grille[CaseDemande+90].etat = 8;
                    grille[CaseDemande+91].etat = 8;
                    grille[CaseDemande+92].etat = 8;
                    grille[CaseDemande+83].etat = 8;
                    grille[CaseDemande+135].etat = 8;
                    grille[CaseDemande+136].etat = 8;
                    grille[CaseDemande+137].etat = 8;
                    grille[CaseDemande+138].etat = 8;
                    grille[CaseDemande+180].etat = 8;
                    grille[CaseDemande+181].etat = 8;
                    grille[CaseDemande+182].etat = 8;
                    grille[CaseDemande+183].etat = 8;
                    grille[CaseDemande+225].etat = 8;
                    grille[CaseDemande+226].etat = 8;
                    grille[CaseDemande+227].etat = 8;
                    grille[CaseDemande+228].etat = 8;

    }
    if(cas == 3)
    {
        grille[CaseDemande].viabilite = 1;
        grille[CaseDemande+1].viabilite = 1;
        grille[CaseDemande+2].viabilite = 1;
        grille[CaseDemande+45].viabilite = 1;
        grille[CaseDemande+46].viabilite = 1;
        grille[CaseDemande+47].viabilite = 1;
        grille[CaseDemande+90].viabilite = 1;
        grille[CaseDemande+91].viabilite = 1;
        grille[CaseDemande+92].viabilite = 1;
    }

}


void EvolutionGeneral(t_c grille[1575], t_v *ville, BITMAP *Buffer, BITMAP *cabane, BITMAP *maison, BITMAP *immeuble, BITMAP *gratteciel)
{
    int verif;

    for(int i = 0; i < 1575; i++)
    {
        verif = VerifierEvolution(grille, i);
        if(verif == 1 && grille[i].jefe != 0)
        {
            evolution(&ville, Buffer, grille, i, cabane, maison, immeuble, gratteciel);
            //regression(&ville, Buffer, grille, i);
            ville->population = ville->population + grille[i].habitant;

        }



    }
}



int VerifierEvolution(t_c grille[1575], int bat)
{

    int difCcycle;
    time(&grille[bat].fcycle);
    difCcycle = difftime(grille[bat].fcycle, grille[bat].dcycle);
    if((difCcycle%15) == 0 && difCcycle != 0)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}





void evolution(t_v *ville, BITMAP *Buffer, t_c grille[1575], int bat, BITMAP *cabane, BITMAP *maison, BITMAP *immeuble, BITMAP *gratteciel)
{
    //Doit prendre en compte le temps. Chaque maison a son propre cycle.

    ville->modeJeu =  2;
    if(ville->modeJeu == 2 /*&& (grille[bat].etat < 6 && grille[bat].etat > 1) || grille[bat].etat == 9*/)       //Capitaliste
    {       //On n'améliore que les maisons

        if(grille[bat].etat == 2 || grille[bat].etat == 9)
        {
            grille[bat].habitant = grille[bat].habitant+10;//Passage d'un terrain vague à une cabane
            grille[bat].etat = grille[bat].etat+1;
            affichageBatiments(Buffer, cabane, grille, bat);

        }
        else if(grille[bat].etat == 3)
        {
            grille[bat].habitant = grille[bat].habitant+40;
        }
        else if(grille[bat].etat == 4)
        {
            grille[bat].habitant = grille[bat].habitant*2;
        }
        else if(grille[bat].etat == 5)
        {
            grille[bat].habitant = grille[bat].habitant*10;
        }





    }
    else if(ville->modeJeu == 3)      //Communiste
    {
        //En mode communiste, la case doit être alimenté en eau pour etre amélioré.
        if(grille[bat].alimentationEAU == 1 && grille[bat].alimentationElec==1)
        {

            if(grille[bat].etat == 2 || grille[bat].etat == 2)
            {
                grille[bat].habitant = grille[bat].habitant+10;//Passage d'un terrain vague à une cabane

            }
            else if(grille[bat].etat == 3)
            {
                grille[bat].habitant = grille[bat].habitant+40;
            }
            else if(grille[bat].etat == 4)
            {
                grille[bat].habitant = grille[bat].habitant*2;
            }
            else if(grille[bat].etat == 5)
            {
                grille[bat].habitant = grille[bat].habitant*10;
            }
            else
            {

            }
        }
        grille[bat].etat = grille[bat].etat+1;

    }
}


void regression(t_v *ville, BITMAP Buffer, t_c grille[1575], int bat)
{
    if(ville->modeJeu == 3 && grille[bat].etat < 7 && grille[bat].etat > 2)      //Communiste : regresse si y'a plus d'eau et elec.
    {
        if(grille[bat].alimentationEAU != 1 || grille[bat].alimentationElec !=1)
        {
            if(grille[bat].etat == 6)
            {
                grille[bat].habitant = grille[bat].habitant - 900;
                grille[bat].etat = grille[bat].etat - 1;
            }
            else if(grille[bat].etat == 5)
            {
                grille[bat].habitant = grille[bat].habitant - 50;
                grille[bat].etat = grille[bat].etat - 1;
            }
            else if(grille[bat].etat == 4)
            {
                grille[bat].habitant = grille[bat].habitant - 40;
                grille[bat].etat = grille[bat].etat - 1;
            }
            else if(grille[bat].etat == 3)
            {
                grille[bat].habitant = grille[bat].habitant - 10;       //Devient un champ de ruine
                grille[bat].etat = 9;       // 9 correspond à la ruine.
            }
        }
    }
    else if(ville->modeJeu == 2 && grille[bat].etat < 6 && grille[bat].etat > 1)     //Capitaliste
    {
        ///rien du tout, il n'y a pas de regression en mode capitaliste
    }

}


















int TrouverSommetSuiv(t_c grille[1575], int s1, int add)
{

    if(grille[s1+add].etat == 2)
    {

        return s1+add;
    }
    else
    {
        return -1;
    }
}






Graphe* CreerGraphe(t_c grille[1575])
{
    Graphe * Newgraphe = (Graphe*)malloc(sizeof(Graphe));
    Newgraphe->pSommet = (pSommet*)malloc(1575*sizeof(pSommet));

    for(int i = 0; i< 1575; i++)
    {
        Newgraphe->pSommet[i] = (pSommet)malloc(sizeof(struct Sommet));
        Newgraphe->pSommet[i]->valeur = i;
        Newgraphe->pSommet[i]->arc = NULL;
        Newgraphe->pSommet[i]->sommet_precedent == NULL;
    }

    int s2;
    for(int s1 = 0; s1 < 1575; s1++)
    {
        if(s1 == 0)
        {
            s2 = TrouverSommetSuiv(grille, s1, 1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
        }
        else if(s1 == 44)
        {
            s2 = TrouverSommetSuiv(grille, s1, -1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }

        }
        else if(s1 = 1530)
        {
            s2 = TrouverSommetSuiv(grille, s1, 1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, -45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }

        }
        else if(s1 = 1574)
        {
            s2 = TrouverSommetSuiv(grille, s1, -1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, -45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
        }
        else if(s1 < 45)
        {
            s2 = TrouverSommetSuiv(grille, s1, 1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, -1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
        }
        else if(s1 > 1530)
        {
            s2 = TrouverSommetSuiv(grille, s1, 1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, -45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, -1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
        }
        else if((s1%45) == 0)
        {
            s2 = TrouverSommetSuiv(grille, s1, -45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
        }
        else if(((s1+1)%45) == 0)
        {
            s2 = TrouverSommetSuiv(grille, s1, -1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, -45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
        }
        else
        {
            s2 = TrouverSommetSuiv(grille, s1, -1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, -45);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
            s2 = TrouverSommetSuiv(grille, s1, 1);
            if(s2 != (-1))
            {
                Newgraphe->pSommet=CreerArete(Newgraphe->pSommet, s2, s1);
            }
        }

    }
    return Newgraphe;
}






// Ajouter l'arête entre les sommets s1 et s2 du graphe
pSommet* CreerArete(pSommet* sommet, int s1, int s2)
{
    if(sommet[s1]->arc == NULL)
    {
        pArc Newarc = (pArc)malloc(sizeof(struct Arc));
        Newarc->sommet = s2;
        Newarc->poids = 1;
        Newarc->arc_suivant = NULL;
        sommet[s1]->arc = Newarc;
        return sommet;
    }

    else
    {
        pArc temp = sommet[s1]->arc;
        while( !(temp->arc_suivant == NULL))
        {
            temp = temp->arc_suivant;
        }
        pArc Newarc = (pArc)malloc(sizeof(struct Arc));
        Newarc->sommet = s2;
        Newarc->poids = 1;
        Newarc->arc_suivant = NULL;

        if(temp->sommet > s2)
        {
            Newarc->arc_suivant = temp->arc_suivant;
            Newarc->sommet = temp->sommet;
            temp->sommet = s2;
            Newarc->poids = 1;
            temp->arc_suivant = Newarc;
            return sommet;
        }

        temp->arc_suivant = Newarc;
        return sommet;
    }
}


//sous programme pour calculer et trouver le plus cours chemin entre 2 sommets grâce à l'algorithme de Djikstra
void Dijkstra(Graphe* g, int s1, int s2)
{
    //initialisation, on met tous les sommets à 0
    for(int i=0; i < 1575; i++)
    {
        g->pSommet[i]->couleur = 0;
    }
    //on colorie le premier sommet
    g->pSommet[s1]->couleur = 1;

    //création d'un tableau pour chaque sommet qui va donner le plus cours chemin (en poids)  par rapport a tous les autres sommets du graphe
    int tab[1575];
    //on met toutes les distances(poids) du sommet de depart jusqu'aux autres sommet à plus l'infini (ici 100000 par ex)
    for(int i = 0; i < 1575; i++)
    {
        tab[i] = 100000;
    }
    //on met la distance du sommet de départ à lui même à 0 car il ne va pas être utiliser
    tab[s1] = 0;

    //sommet intermédiaire
    int sinter = -1;

    //compléter le tableau qui vient d'être créer
    CompleterTableau(g, s1, tab);
    //AffichageTableau(g, s1, tab);

    //tant que le sommet d'arrivée n'est pas égale au sommet intermédiaire :
    while(s2 != sinter)
    {
        //on cherche quel sommet à le plus petit poids avec le sommet initial
        sinter = ChercherSommet(g, tab);
        //si ce sommet intermédiaire est le sommet d'arrivée alors on lui affecte la valeur pour pouvoir arrêter le sous programme
        if(sinter == 100)
        {
            sinter = s2;
        }

        //on colorie le nouveau sommet utilisé car comme nous l'avons déja analyser nous l'analyseront pas une seconde fois
        g->pSommet[sinter]->couleur = 1;



        //on continue de compléter le tableau
        CompleterTableau(g, sinter, tab);
        //AffichageTableau(g, s1, tab);


    }

    //afffichage poids
    printf("\nLe poids du chemin le plus court pour aller de %d a %d est %d !\n", s1, s2, tab[s2]);

    //affichage chemin
    printf("Chemin :  %d ", g->pSommet[s2]->valeur);
    while(g->pSommet[s2]->valeur != s1)
    {
        g->pSommet[s2] = g->pSommet[s2]->sommet_precedent;
        printf("--> %d ", g->pSommet[s2]->valeur);
    }
    printf("\n");
}


//sous programme qui permet de compléter le tableau des plus petits poids entre le sommets initiale et les autres sommets
void CompleterTableau(Graphe * g, int s, int * tab)
{
    pArc arc = g->pSommet[s]->arc;
    Graphe * g2 = (Graphe*)malloc(sizeof(Graphe));
    g2 = g;
    //tant qu'il reste des arcs non analysés entre le sommet en cours d'analyse et ses sommets adjacents
    while(arc != NULL)
    {
        //on regarde dans un premier temps si le sommet adjacent à déja été analysé
        if(g->pSommet[arc->sommet]->couleur == 0)
        {
            //s il n'existe pas encore de poids avec le sommet initial faire
            if(tab[arc->sommet] == 100000)
            {

                //le poids par rapport au sommet initiale est égale au poids entre les 2 sommets adjacents
                //plus le poids entre le sommet adjacent et le sommet initiale
                tab[arc->sommet] = arc->poids + tab[s];
                //on retient quel est le chemin pour parvenir à ce poids
                g2->pSommet[arc->sommet]->sommet_precedent = g2->pSommet[s];
            }

            //si le poids avec le sommet initiale est supérieur au potentiel poids entre les 2 sommets adjacents
            //plus le poids entre le sommet adjacent et le sommet initiale faire
            else if(tab[arc->sommet] > tab[s] + arc->poids)
            {

                //le poids par rapport au sommet initiale est remplacé par le poids entre les 2 sommets adjacents
                //plus le poids entre le sommet adjacent et le sommet initiale
                tab[arc->sommet] = tab[s] + arc->poids;
                //on retient quel est le chemin pour parvenir à ce poids
                g2->pSommet[arc->sommet]->sommet_precedent = g2->pSommet[s];
            }

            //si le poids avec le sommet initiale est inférieur au potentiel poids entre les 2 sommets adjacents
            //plus le poids entre le sommet adjacent et le sommet initiale faire
            else if(tab[arc->sommet] < tab[s] + arc->poids)
            {
                //ne rien faire, on doit garder la valeur car c'est le plus petit poid
            }

            //sinon
            else
            {

                //le poids par rapport au sommet initiale est égale à son propre poids plus le poids entre les 2 sommets adjacents
                tab[arc->sommet] = arc->poids + tab[arc->sommet];
                //on retient quel est le chemin pour parvenir à ce poids
                g2->pSommet[arc->sommet]->sommet_precedent = g2->pSommet[s];
            }

        }
        //on va regarder l'arc suivant donc le poids avec un autre chemin adjacent(s'il en existe encore !)
        arc = arc->arc_suivant;

    }

}

//sous programme pour chercher le sommet qui pour le moment à le plus petit poid avec le sommet initial
int ChercherSommet(Graphe * g, int tab[])
{
    int smin = 100;
    int inter = 100;
    //pour tous les sommets
    for(int i = 0; i < 1575; i++)
    {
        //seulement si le sommet n'est pas encore colorié donc pas encore analysé
        if(g->pSommet[i]->couleur == 0)
        {

            //pour tous les autres sommets (donc on va effectuer toutes les combinaisons entre sommets possible)
            for(int j = 0; j < 1575; j++)
            {
                //seulement si le sommet n'est pas encore colorié donc pas encore analysé
                if(g->pSommet[j]->couleur == 0)
                {
                    //on cherche le plus petit poid possible
                    if(tab[i] > tab[j]  && inter > tab[j])
                    {

                        smin = j;
                        inter = tab[j];

                    }
                }

            }
        }
    }
    //on retourne le sommet trouvé
    return smin;
}



/*
int ParcoursBFS(Graphe* g, int s0)
{
    int compteur = 0;
    //on met toutes les couleurs en blanc car les sommets ne sont pas encore marquées
    for(int i=0; i < 1575; i++)
    {
        g->pSommet[i]->couleur = 0;
    }

    //création et initialisation d’un tableau à -1 .
    int *tab = (int*)malloc(g->ordre * sizeof(int));
    for(int i = 0; i < g->ordre; i++)
    {
        tab[i]=-1;
    }
    ///preds[i] donnera le numéro du prédécesseur du sommet i
    ///dans les chemins obtenus
    ///Au départ les sommets n’ont pas de prédécesseur (valeur -1)
    ///Le sommet initial n’aura pas de prédécesseur. Les sommets non découverts
    ///(non accessibles à partir du sommet initial) non plus.

    t_file f;
    f.tete = f.fin = NULL;
    ///elle contiendra les numéros des sommets enfilés.

    //on demande à l'utilisateur de chosiir le somme initial



    //on enfile le sommet choisit et on le colorie
    enfiler(&f, s0);
    g->pSommet[s0]->couleur = 1;

    //tant que la file n'est pas vide
    while(f.tete != NULL)
    {

        int num = defiler(&f);
        struct Arc* temp = g->pSommet[num]->arc;

        while(temp!=NULL) //ou si egale au numero du sommet d'arrivée qu'on souhaite voir tp2
            {
                //on récupère le numéro du sommet
                // vers lequel conduit l'arc
                int num2=temp->sommet;
                //si ce sommet n'est pas marqué
                if(g->pSommet[num2]->couleur==0)
                {
                    //on l'enfile
                    enfiler(&f,num2);
                    //on le marque
                    g->pSommet[num2]->couleur=1;
                    //on note que son prédécesseur est le sommet défilé
                    tab[num2] = num;

                }
                temp=temp->arc_suivant;
                compteur++;


            }
        //pour afficher plus lisiblement
        /*if(f.tete != NULL)
        {
            printf("%d --> ", num);
        }
        else
        {
            printf("%d", num);
        }*//*


    }
    printf("compteur = %d\n", compteur);
}

*/
/*


//sous programme pour enfiler
void enfiler(t_file *f, int num)
{

    t_maillon* nouveau;
    nouveau = (t_maillon*)malloc(sizeof(t_maillon));
    if (nouveau == NULL)
    {
        printf("pb d'allocation Dyn. de maillon\n");
    }
    else
    {
        ///affectation de la valeur du maillon
        nouveau->valeurElement = num;
        nouveau->suivant = NULL;

        ///ajout du maillon dans la liste
        if (estVide(f) == 1)
        {
            ///liste vide
            f->tete = nouveau;
            f->fin = nouveau;
        }
        else
        {
            ///liste non vide donc ajout en tete et mise à jour du pointeur
            nouveau->suivant = f->tete;
            f->tete = nouveau;
        }
    }

}*/
/*
//sous programme pour défiler et donc récupérer un sommet
int defiler(t_file *f)
{
    t_maillon* ptcourant = NULL;
    t_maillon* ptprecedent = NULL;
    int res;
    if (estVide(f) == 1)
    {
        printf("il n'y a aucun element à supprimer. La file est vide\n");
        return -1;
    }
    else
    {
        ptcourant = f->fin;
        res = ptcourant->valeurElement;

        ///il faut regarder s'il n'y a plus qu'un seul element qui rendra apres cette operation de suppression la liste vide
        if (f->fin != f->tete)
        {
            ///parcourir la liste pour atteindre l'avant dernier maillon
            ptcourant = f->tete;
            ptprecedent = ptcourant;
            while(ptcourant->suivant != NULL)
            {
                ptprecedent = ptcourant;
                ptcourant = ptcourant->suivant;
            }
        ptprecedent->suivant = NULL;
        f->fin = ptprecedent;
        }
        else
        {
            f->fin = NULL;
            f->tete = NULL;
        }
    free(ptcourant);
    return res;
    }

}

*/

/*
//regarder si une file est vide ou non     Renoie 1 si la file est vide et renvoie 0 si la file n'est pas vide
int estVide(t_file* f)
{
    if(f->tete == NULL && f->fin == NULL)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
*/
